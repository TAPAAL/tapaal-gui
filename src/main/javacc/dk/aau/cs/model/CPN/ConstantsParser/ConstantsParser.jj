options {
    STATIC = false;
}
PARSER_BEGIN(ConstantsParser)
package dk.aau.cs.model.CPN.ConstantsParser;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import dk.aau.cs.model.CPN.ColorType;
import dk.aau.cs.model.tapn.Constant;
import dk.aau.cs.model.CPN.Variable;
import dk.aau.cs.model.tapn.TimedArcPetriNetNetwork;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

public class ConstantsParser {
    private static final String ERROR_PARSING_CONSTANTS_MESSAGE = "TAPAAL encountered an error trying to parse the constants";

    private static final Map<String, Constant> constants = new HashMap<String, Constant>();
    private static final Map<String, ColorType> colorTypes = new HashMap<String, ColorType>();
    private static final Map<String, Variable> variables = new HashMap<String, Variable>();
    private static TimedArcPetriNetNetwork network;

    public static void parse(String constantsToParse, TimedArcPetriNetNetwork network) throws ParseException {
        ConstantsParser.network = network;
        ConstantsParser parser = new ConstantsParser(new StringReader(constantsToParse));
        constants.clear();
        colorTypes.clear();
        variables.clear();

        parser.startParsing();
        ColorType dot = new ColorType("dot");
        dot.addColor("dot");    
        colorTypes.put("dot", dot);

        List<Constant> constantsList = constants.values()
                                                .stream()
                                                .collect(Collectors.toList());

        List<ColorType> colorTypesList = colorTypes.values()
                                                   .stream()
                                                   .collect(Collectors.toList());
        
        List<Variable> variablesList = variables.values()
                                                .stream()
                                                .collect(Collectors.toList());

        network.setConstants(constantsList);
        if (network.isColored()) {
            network.setColorTypes(colorTypesList);
            network.setVariables(variablesList);
        }
    }

    private static void idExists(String id) throws ParseException {
        if (constants.containsKey(id)) {
            throw new ParseException("Constant with name \"" + id + "\" already exists");
        }

        if (colorTypes.containsKey(id)) {
            throw new ParseException("Color type with name \"" + id + "\" already exists");
        }

        if (variables.containsKey(id)) {
            throw new ParseException("Variable with name \"" + id + "\" already exists");
        }
    }
}

PARSER_END(ConstantsParser)

TOKEN :
{
    <SEPARATOR: ";">
    |
    <EQ: "=">
    |
    <COMMA: ",">
    |
    <SBRACKET: "[">
    |
    <EBRACKET: "]">
    |
    <IS: "is">
    |
    <IN: "in">
    |
    <#ALPHA: ["a"-"z","A"-"Z"]>
    |
    <#ALPHANUM: ["a"-"z","A"-"Z","0"-"9"]>
    |
    <INTEGER: ["0"-"9"] | (["1"-"9"] (["0"-"9"])*)>
    |
    <ID: <ALPHA> ("_" | <ALPHANUM>)*>
}

SKIP :
{
    " "
  | "\t"
  | "\n"
  | "\r"
}

void startParsing() :
{}
{
    (values() <SEPARATOR>)* <EOF>
}

void values() :
{}
{
    LOOKAHEAD(2) constants() | 
    LOOKAHEAD(2) colorTypes() | 
    LOOKAHEAD(2) variables()
}

void constants() :
{
    Token id, value;
}
{
    id = <ID> <EQ> value = <INTEGER> { 
        idExists(id.image);
        constants.put(id.image, new Constant(id.image, Integer.parseInt(value.image)));
    }
}

void colorTypes() :
{
    Token id;
    List<String> values = new ArrayList<String>();
}
{
    id = <ID> <IS> <SBRACKET> colorTypeValues(values) <EBRACKET> { 
        if (!network.isColored()) {
            throw new ParseException("Color types are not allowed in uncolored networks");
        }

        idExists(id.image);

        ColorType ct = new ColorType(id.image);
        ct.addColors(values);

        for (String color : values) {
            if (color.equals(id.image)) {
                throw new ParseException("Color with name \"" + id.image + "\" already exists");
            }
        }

        colorTypes.put(id.image, ct); 
    }
}

void colorTypeValues(List<String> values) :
{
    Token id;
}
{
    id = <ID> { values.add(id.image); } 
    ((<COMMA> id = <ID>) { values.add(id.image); })*
}

void variables() :
{
    Token id, type;
}
{
    id = <ID> <IN> type = <ID> {
        if (!network.isColored()) {
            throw new ParseException("Variables are not allowed in uncolored networks");
        }

        idExists(id.image);

        if (!colorTypes.containsKey(type.image)) {
            throw new ParseException("Color type with name \"" + type.image + "\" does not exist");
        }

        variables.put(id.image, new Variable(id.image, colorTypes.get(type.image)));
    }
}